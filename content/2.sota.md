## Related work
{:#related-work}

Existing web interface description frameworks fall into several distinct families,
each optimized for different usage scenarios.
However, most fall short in their ability to formally and completely describe how data flows from write operations
to corresponding reads or how internal state transitions occur within the system, across endpoints.

### RPC and Syntactic Interface Specifications

Remote Procedure Call (RPC) style specification languages such as [WADL](cite:cites spec:wadl) and [OpenAPI/Swagger](cite:cites openapi)
primarily offer syntactic descriptions of web APIs.
These specifications define endpoints, parameters, and payload schemas in formats like XML (WADL) or JSON/YAML (OpenAPI).
Although they support [URI templates](cite:cites uri-template) and detail input-output structures,
they do not capture semantic relationships between operations, nor do they support hypermedia or model the consequences of state modifications.
OpenAPI is widely used for generating documentation and client code, but it only supports syntactic interoperability,
requiring human developers or intelligent agents to infer the meaning of operations.

Similarly, [AsyncAPI](cite:cites asyncapi) extends the RPC-style description model to event-based APIs,
offering a syntax for defining message-driven architectures.
It describes publish/subscribe channels, message schemas, and communication protocols (e.g., MQTT, WebSocket),
which makes it well-suited for heterogeneous environments.
However, like OpenAPI, AsyncAPI lacks the ability to model how emitted messages impact application state.
Messages are specified structurally, but not semantically;
the relationship between an event and the resulting system state is left implicit.

Our solution will convey how the underlying system resources are modified by describing the interaction between write operations,
dereferenceable information resources and non-accessible resources (e.g. an underlying database). 

### Tool Invocation and Agent-Oriented APIs

The [Model Context Protocol (MCP)](cite:cites mcp) represents a newer class of interface which is self-descriptive and aimed at AI agent interoperability.
Since MCP allows external tools to advertise available resources (readable data) and tools (invokable operations) to large language models (LLMs),
enabling structured interaction via natural language, MCP could be used as a data interface.
While this model does conceptually align reads and writes with corresponding resources and tools,
it lacks formal semantics.
Descriptions in MCP are purely textual, and while this enables flexible reasoning by LLMs,
it does not guarantee unambiguous interpretations of system behavior or consequences of actions.
As a result, agents cannot reliably infer the downstream effects of invoking a particular tool.
The solution we present tackles the reliability problem by algebraically describing the relationship.

### Semantic Web Descriptions

In the context of the Semantic Web, interface description languages aim to embed operational semantics into Linked Data.
The [Hydra Core Vocabulary](cite:cites lanthaler2013hydra) allows API providers to annotate resources with affordances -
like descriptions of possible state transitions.
This enables clients to discover valid actions dynamically through hypermedia controls.
While Hydra provides an elegant model for describing RESTful interactions, it fundamentally assumes symmetry between inputs and outputs.
It does not support asymmetric interfaces, for example for changing the owner of a pet in [](#interface-viz).
Therefore, while Hydra enables simple autonomous interactions (e.g., resource creation or deletion),
[it cannot express the full semantics of data flows](cite:cites hyrda-extension-with-response-shapes).

[OWL-S](cite:cites owl-s) provides a semantically rich framework for describing Web services,
including preconditions, effects, and complex process models.
It supports abstract reasoning about resource modifications, making it theoretically capable of modeling service composition.

[RESTdesc](cite:cites restdesc) extends ideas similar to Hydra ideas using [Notation3 (N3)](cite:cites n3),
enabling interface contracts through logical implications.
<!-- More expresive: see Hydra paper: Since Hydra descriptions can easily be transformed into RESTdesc descriptions, -->
Although more expressive than Hydra, RESTdesc similarly lacks a formal model of the data lifecycle;
it does not provide mechanisms for tracing how data flows through write-to-read transitions across interfaces.


To our knowledge all semantic web descriptions thus lack direct mechanisms for describing concrete modifications to intermediate resources
(e.g., `<database>` in [](#interface-viz)).
As such, they are not well-suited to applications requiring fine-grained reasoning about how specific API calls alter intermediate resources.

### Query-Based Interfaces


Interfaces like [SPARQL Protocol](cite:cites spec:sparqlprot) and [GraphQL](cite:cites graphql) expose an underlying dataset as a single HTTP resource.
GraphQL will allow you to describe different available resources and manipulations,
but similar to syntactic interface descriptions,
the description of the resources is done through natural language leaving room to interpretation error. 
The SPARQL protocol on the other hand exposes is, in absence of further policies, inherently symmetrical,
meaning the shape of the data one can read matches that which can be written.
This limits their use when determinism is needed, or when multiple or intermediate resources are required,
additionally their interaction method comes at [significant costs for the data provider](cite:cites sparql-is-heavy).
Our solution enables (and encourages) the semantic definition of multiple resources and additionally allows you to use multiple interaction methods.
