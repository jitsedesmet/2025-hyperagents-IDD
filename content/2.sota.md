## Related work
{:#related-work}

Existing web interface description frameworks fall into several distinct families,
each optimized for different usage scenarios.
However, most fall short in their ability to formally and completely describe how data flows from write operations
to corresponding reads or how internal state transitions occur within the system, across endpoints.

### RPC and Syntactic Interface Specifications

Remote Procedure Call (RPC) style specification languages such as [WADL](cite:cites spec:wadl) and [OpenAPI/Swagger](cite:cites openapi)
primarily offer syntactic descriptions of web APIs.
These specifications define endpoints, parameters, and payload schemas in formats like XML (WADL) or JSON/YAML (OpenAPI).
Although they support [URI templates](cite:cites uri-template) and detail input-output structures,
they do not capture semantic relationships between operations, nor do they support hypermedia or model the consequences of state modifications.
OpenAPI is widely used for generating documentation and client code, but it only supports syntactic interoperability,
requiring human developers or intelligent agents to infer the meaning of operations.

Similarly, [AsyncAPI](cite:cites asyncapi) extends the RPC-style description model to event-based APIs,
offering a syntax for defining message-driven architectures.
It describes publish/subscribe channels, message schemas, and communication protocols (e.g., MQTT, WebSocket),
which makes it well-suited for heterogeneous environments.
However, like OpenAPI, AsyncAPI lacks the ability to model how emitted messages impact application state.
Messages are specified structurally, but not semantically;
the relationship between an event and the resulting system state is left implicit.

Our solution will convey how the underlying system resources are modified by describing the interaction between write operations,
dereferenceable information resources and non-accessible resources (e.g. an underlying database). 

### Tool Invocation and Agent-Oriented APIs

<span class="comment" data-author="RV">I wonder if we're being ambiguous about the word <q>interface</q> here, and whether that's intentional. Up to this point, the word <q>interface</q> could be replace by <q>HTTP interface</q> and the points would still stand. (In fact, I did such a mental substitution in my head as I was reading the text.) But now, we're talking about MCP, in which the <q>interface</q> no longer is a collection of read/write resources. Both are interfaces on some semantic level, but the commonalities are limited. Furthermore, some of the text in the Introduction (I think) no longer works when using the wider definition of <q>interface</q> as we're doing here.</span>

The [Model Context Protocol (MCP)](cite:cites mcp) represents a newer class of <span class="rephrase" data-author="RV">interface descriptions</span> aimed at AI agent interoperability.
<span class="comment" data-author="RV">different kind of interface, IMHO. Does our framework also do anything for those kinds of interface? Or what is the exact positioning? I think you'll need to use <q>data interfaces</q> and <q>model interfaces</q> to have a clear conversation. What we offer (I think) are descriptions for data interfaces. It might be that _model_ interfaces _use_ those descriptions of data interfaces (and that would thus be an interesting value proposition), but I don't think our descriptions apply to model interfaces. The text leaves this ambiguous at the moment.</span>
MCP allows external tools to advertise available resources (readable data) and tools (invokable operations) to large language models (LLMs),
enabling structured interaction via natural language.
While this model does conceptually align reads and writes with corresponding resources and tools,
it lacks formal semantics.
Descriptions in MCP are purely textual, and while this enables flexible reasoning by LLMs,
it does not guarantee unambiguous interpretations of system behavior or consequences of actions.
As a result, agents cannot reliably infer the downstream effects of invoking a particular tool.
The solution we present tackles the reliability problem by algebraically describing the relationship.

### Semantic Web Descriptions

In the context of the Semantic Web, interface description languages aim to embed operational semantics into Linked Data.
The [Hydra Core Vocabulary](cite:cites lanthaler2013hydra) allows API providers to annotate resources with affordances -
like descriptions of possible state transitions.
This enables clients to discover valid actions dynamically through hypermedia controls.
While Hydra provides an elegant model for describing RESTful interactions, it fundamentally assumes symmetry between inputs and outputs.
It does not support asymmetric interfaces, for example for changing the owner of a pet in [](#interface-viz).
Therefore, while Hydra enables simple autonomous interactions (e.g., resource creation or deletion),
[it cannot express the full semantics of data flows](cite:cites hyrda-extension-with-response-shapes).
<span class="comment" data-author="RV">Be specific about what that means (and you can remove some Hydra detail to make space). How it works is less relevant than what the solution does and doesn't cover.</span>

<!--
<span class="comment" data-author="RT">
Especially in the context of query (read) interfaces such as TPF,
it's also important to mention that Hydra is lacking due to its inability to describe what kind of response will be returned based on the given request.
See https://www.rubensworks.net/publications/taelman_kcap_2017/ IDD solves this problem, by using queries similarly to the proposed solution.</span>
-->

[OWL-S](cite:cites owl-s) provides a semantically rich framework for describing Web services,
including preconditions, effects, and complex process models.
It supports abstract reasoning about resource modifications, making it theoretically capable of modeling service composition.
[RESTdesc](cite:cites restdesc) extends similar ideas using [Notation3 (N3)](cite:cites n3),
enabling interface contracts through logical implications.
<!-- More expresive: see Hydra paper: Since Hydra descriptions can easily be transformed into RESTdesc descriptions, -->
Although more expressive than Hydra, RESTdesc similarly lacks a formal model of the data lifecycle;
it does not provide mechanisms for tracing how data flows through write-to-read transitions across interfaces.


To our knowledge all semantic web descriptions thus lack direct mechanisms for describing concrete modifications to intermediate resources
(e.g., `<database>` in [](#interface-viz)).
As such, they are not well-suited to applications requiring fine-grained reasoning about how specific API calls alter intermediate resources.

### Query-Based Interfaces

Technologies like [SPARQL Protocol](cite:cites spec:sparqlprot) and [GraphQL](cite:cites graphql) expose an underlying data space as a single HTTP resource.
In absence of further policies, this makes them inherently symmetrical, meaning the shape of the data one can read matches that which can be written.
<span class="comment" data-author="RV">Not true for GraphQL though, where one can/must define specific operations, I thought?</span>
This limits their use when multiple resources are required (e.g. a resource derived from multiple other resources),
additionally their interaction method comes at [significant costs for the data provider](cite:cites sparql-is-heavy).
Our solution enables (and encourages) the definition of multiple resources and additionally allows you to use multiple interaction methods.


<!--
<span class="comment" data-author="RT">I would also talk about TPF here, as it's a nice example of how Hydra can be used. But for that, it's probably better to move 2.4 to after 2.5.</span>
JDS: I understand, but will currently limit what I include to the bare minimum because of the page limit
-->

<!--

### Summary

While existing interface description frameworks offer valuable capabilities - such as syntactic validation,
documentation generation, and limited semantic affordancesâ€”none fully model the flow of data from writes to reads in a machine-interpretable way.
They often assume symmetrical interactions, leave semantics to natural language, or operate at levels too abstract to capture operational effects precisely.

In contrast, the Interface Data Description (IDD) approach introduced in this work directly models how event-space operations (writes)
map to derived read views in state space.
By aligning API interfaces with RDF-based algebraic transformations, IDD enables automated agents to reason about available reads,
discover valid modification strategies, and predict the consequences of their actions.
This level of semantic expressiveness fills a critical gap left by existing specification languages.

-->
