## Related work
{:#related-work}

Existing web interface description frameworks fall into several families,
each with different strengths and limitations in expressing API behavior.

Remote Procedure Calling (RPC) style specification languages
(like [WADL](cite:cites spec:wadl) or [OpenAPI/Swagger](cite:cites openapi)) enumerate endpoints,
parameters, and payload schemas, but they are essentially syntactic descriptions.
WADL (XML-based) and Swagger/OpenAPI (JSON/YAML-based) expose [URI templates](cite:cites uri-template) with HTTP methods and expected inputs/outputs,
but neither supports hypermedia nor formal operational semantics.
For example, Swagger/OpenAPI is widely used to generate documentation and client code,
but it "only supports syntactic interoperability" - meaning the semantics of what the various calls return or modify is left to the API user.

Similarly, the [AsyncAPI](cite:cites asyncapi) specification creates a syntactic description of event based APIs.
It uses YAML to describe message-driven (publish/subscribe) interfaces.
AsyncAPI was originally an adaptation of the openAPI spec and still shares as much of the same primitives as possible.
AsyncAPI specifications documents channels, message schemas, and operations (publish/subscribe) in detail,
but are unable to encode the effect of an event on application state.
They specify that messages are sent or received on a channel with a given schema,
but not the underlying state transitions those messages trigger.
Interestingly, since many protocols exist, AsyncAPI effectively tackles the interface heterogeneity issue by explicitly specifying the used protocol (e.g. websockets, MQTT) such that clients (producers or consumers) know how to communicate with the server.

A new wave of work on AI agents and tool integration has emerged, which touches on interface description.
The [Model Context Protocol (MCP)](cite:cites mcp) is a recent description/ protocol designed to let large-language-model-based agents access external tools and data sources.
MCP standardizes a way for tools to present "resources", "prompts", and "tools" to an AI agent,
somewhat analogous to operations in an API - a resource can be seen as something you can read while a tool can be seen as a write in the context of asymmetric interfaces.
In theory,
one could wrap an existing REST API with an MCP server so that the agent can invoke it via natural language or structured messages.
However, MCP only provides descriptions though natural language.
As a result, MCP does not get a complete understanding of the semantics of state transitions.
An LLM can reason on the natural language but, natural language may fail to clearly communicate the exact semantics of state translations.
As a result an LLM will still struggle to predict the consequences of its actions.

Query endpoint interfaces like [SPARQL endpoints](cite:cites spec:sparqlprot) and [GraphQL](cite:cites graphql)
can declare their underlying data schema and allow various operations to mutate the dataset defined on the query interaction model/ protocol.
The interface can however be seen as a symmetric interface with a complex interaction method,
this is because the effective data model available for reads is the same how you update.


Linked-Data and Semantic Web specific approaches aim to make APIs more self-describing through RDF and ontologies.
The [Hydra Core Vocabulary](cite:cites lanthaler2013hydra) is a prominent example:
it embeds an API's affordances into Linked Data.
Hydra allows a server to "advertise valid state transitions" as part of resource representations.
However, since the resource manipulations are only defined in the context of what data you can read, hydra does nott support trully asymmetric interfaces.
For example, an interface where the creation of one resource implies the deletion of another cannot be expressed through a hydra specification.
Even though it fails to describe asymmetric interfaces,
the ideas presented are very interesting though since an autonomous agent that wants to perform simple resource creations and deletions could do so on the interface simply by consuming the description - all required semantics for these operations are captured in the description.

[RESTdesc](cite:cites restdesc) has similar goals to Hydra but uses implications declared using [Notation3](cite:cites n3)- it is strong but similarly does not allow to allow you to model the data flow.

[OWL-S](cite:cites owl-s) is a way to describe web services and the underlying processes.
It allows you to describe state changes but only in an abstract way.
Concretely, it does not allow you explicitly state how some underlying state model changes.

