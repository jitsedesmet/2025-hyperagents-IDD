## Annex: pet shop example
{:#annex}

Through this annex we will provide a tangible example to clarify our vision.
We will provide an example description of a simple interface used by a pet shop.
It allows you to register owners and link pets to their owner.
We will register a few endpoints to this system:

1. [**\<get-owners\>**](#5.get-owners): allows you to fetch a list of URIs of all owners
2. [**\<get-owner\>**](#6.get-owner): allows you to fetch an owner with its pets.
3. [**\<post-owner\>**](#1.post-owner): allows you to register a new owner to the system.
4. [**\<patch-owner\>**](#2.patch-owner): allows you to patch an existing owner.
5. [**\<change-owner\>**](#3.change-owner): allows you to change the ownership of a pet.
6. [**\<transfer-events\>**](#7.websocket): A websocket that emits pet transfers.

Through the endpoints of 1-4 we will show that it is possible to describe a traditional HTTP/REST interface,
while endpoint 5 shows the power of asymmetric interfaces,
endpoint 6 shows the potential to model events on a mixed system.
Endpoint 5 shows that we can model operations not possible through traditional descriptions such as transferring the ownership of a pet,
which would traditionally require the client to delete the original pet and create a new pet with the same properties somewhere else.
Even though this example looks easy,
it is a placeholder for a range of issues where an endpoint can serve as a way to afford consistent state transitions.
To facilitate the reader, we already explicitly share the [shape of the database](https://rdfshape.weso.es/link/17478219300) we will create.

<!--
```shex
prefix xsd: <http://www.w3.org/2001/XMLSchema#> 
prefix ex: <http://example.org/>
<owner-shape> {
  a  [ex:owner];
  ex:name xsd:string;
  ex:pet @<pet-shape>+;
}
  
<pet-shape> {
  a [ex:pet] ;
  ex:name xsd:string ;
  ex:age xsd:positiveInteger ;
}
```
-->

[](#5.get-owners) shows how we can declare **\<get-owners\>**,
and [](6.get-owner) shows how we can declare **\<get-owner\>**.
Both definitions reside within the state-space defined in our vision.
Next we can define the write interfaces, [](#1.post-owner), [](#2.patch-owner), and [](#3.change-owner)
declare `<post-owner>`, `<patch-owner>`, and `<change-owner>` respectively.
All write interfaces exist in the event-space.
To declare an event-space read resource, one simple dclare the resource in function of an existing event-space resource.
An example is given in [](#7.websocket).
Finally, we can construct the database in the context of the defined write interfaces,
this is done in [](#4.database-def).

<figure id="5.get-owners" class="listing">
````/code/5.get-owners.ttl````
<figcaption markdown="block">
Definition of a state-space endpoint accessible on the URI `<http://example.org/owners>` through an HTTP-GET returning a turtle document.
The endpoint is a simple view of the state-space `<database>` resource/ graph and returns a set of IRI's representing the registered owners.
</figcaption>
</figure>

<figure id="6.get-owner" class="listing">
````/code/6.get-owner.ttl````
<figcaption markdown="block">
Definition of a collection of state-space endpoints by using uri-templates and binding the variables.
The endpoint returns a single owner and all their pets with their properties.
</figcaption>
</figure>


<figure id="1.post-owner" class="listing">
````/code/1.post-owner.ttl````
<figcaption markdown="block">
Definition of a event-space write interface on the uri `https://example.org/owners` requiring a HTTP post using the turtle file format.
The definition requires a specified input shape and performs an initial mapping on the posted data such that it maps the shape of the database.
The endpoint will allow clients to create a new owner with a number of initial pets.
</figcaption>
</figure>

<figure id="2.patch-owner" class="listing">
````/code/2.patch-owner.ttl````
<figcaption markdown="block">
Definition of a collection of event-space write interfaces by using uri-templates and binding the variables.
The endpoint takes a specific input shape and perform a mapping such that the later system knows the context of the emitted message.
Different approaches exist but through this mapping we want to show various ways in which you can define your system.
The endpoint will allow clients to patch the name of the targeted owner.
</figcaption>
</figure>

<figure id="3.change-owner" class="listing">
````/code/3.change-owner.ttl````
<figcaption markdown="block">
Definition of a collection of event-space write interfaces using uri-templates and binding the values.
The endpoint does not require any content-body since the full semantics are defined within the uri itself.
The execution of the operation queries the database version prior to the execution (as if the database is locked),
and validates the pet id corresponds to the current owner id. It also verifies that the new-owner is an existing one.
From that data, a new event is created using RDF 1.2. The new event lists the triples to be removed and the triples to be added. 
</figcaption>
</figure>

<figure id="7.websocket" class="listing">
````/code/7.websocket.ttl````
<figcaption markdown="block">
Definition of an event-space read interface on the uri `https://example.org/transfer-events`.
It derives its messages from the events emitted by the `<change-owners>` write endpoints.
Since the resource is derived using mapping from another event-space resource, it too is an event-space resource.
To allow for optimal usage of this event space, we decided to bind it to a websockets interaction method/ protocol.
</figcaption>
</figure>

<figure id="4.database-def" class="listing">
````/code/4.database-def.ttl````
<figcaption markdown="block">
Definition of a database is state-space by defining its relation to three event-space resources.
The conversion from event-space to state-space is performed by set operations.
This example arbitrarily chose to use named graphs to indicate what set operations are performed over what triples but many other choices could be made.
</figcaption>
</figure>

### Example flow
{:#flow-example}


Consider the dataset modeled in our earlier examples.
There are two write interfaces: `<post-owner>` and `<patch-owner>`.
Each describes the shape of its expected input and how it transforms that input into internal event-space resources.

The `<post-owner>` interface expects input of the following shape:
```shex
<> {
    ex:name xsd:string;
    ex:pets {
        foaf:name xsd:string;
        ex:age    xsd:int;
    }*
}
```
Its mapping transforms this input into a new graph that can be expressed through its relation with the input:
```
eval()_1 a ex:owner
eval()_1 ex:name xsd:string_1
eval()_1 ex:pets* eval()_2
eval()_2 a ex:pet
eval()_2 ex:name xsd:string_2
eval()_2 ex:age xsd:int_1
```

The `<patch-owner>` interface, similarly, transforms a patch document:
```shex
<> {
    ex:name xsd:string;
}
```
into
```
eval()_3 a ex:owner-patch
eval()_3 ex:name xsd:string_3
eval()_3 ex:resource ?patch
```

These event-space outputs are then combined via set operations (e.g., union, difference)
to define the durable `<database>` state.
From the mappings, we can infer the resulting shape of this dataset:
```
eval()_1 a ex:owner
eval()_1 ex:name xsd:string_1 | xsd:string_3
eval()_1 ex:pets* eval_2()
eval()_2 a ex:pet
eval()_2 ex:name xsd:string_2
eval()_2 ex:age xsd:int_1
```

Read interfaces such as `<get-owners>` and `<get-owner>` provide access to this derived state.
Suppose an agent wants to change the name of a specific owner,
e.g. deleting triple `<some-owner> ex:name "some name"` and inserting triple `<some-owner> ex:name "new name"`.
The agent traces the existing triple to its origin:
it is derived from either xsd:string_1 or xsd:string_3 in the event mappings.
It identifies that the only interface capable of replacing `ex:name` for an existing owner is `<patch-owner>`,
which takes a target resource and a new name as input.
Thus, the agent deduces that to perform the update, it must submit:
`ex:owners/{uuid} ex:name "new name"` to the `<patch-owner>` endpoint.
