## Annex: pet shop example
{:#annex}

This annex provides a concrete example to illustrate our vision,
using Turtle syntax and a shared base IRI across examples.
The used vocabulary is tentative.
We describe a simple interface for a pet shop system that allows users to register pet owners and associate pets with them.
The system exposes several endpoints, as visualized in [](#interface-viz):

1. [**\<get-owners\>**](#5.get-owners): retrieves a list of URIs representing all registered owners
2. [**\<get-owner\>**](#6.get-owner): fetches an individual owner along with their associated pets
3. [**\<post-owner\>**](#1.post-owner): registers a new owner in the system
4. [**\<patch-owner\>**](#2.patch-owner): updates an existing owner
5. [**\<change-owner\>**](#3.change-owner): transfers a pet from one owner to another
6. [**\<transfer-events\>**](#7.websocket): a WebSocket endpoint that emits pet ownership transfer events

Endpoints 1â€“4 demonstrate how a traditional HTTP/REST interface can be described using our approach.
Endpoint 5 highlights the expressiveness of asymmetric interfaces by modeling an ownership transfer -
an operation that would traditionally require clients to delete and recreate pet records.
This example illustrates a broader category of use cases where endpoints can enforce consistent state transitions.
Endpoint 6 showcases how event-based systems can be integrated into the same model.

To assist the reader, we explicitly define the [shape of the underlying database](https://rdfshape.weso.es/link/17478219300) in [](#0.database-shape).

<figure id="interface-viz">
<img src="images/interface-example-viz.svg" alt="Visual representation of the interface" style="object-fit: contain;"/>
<figcaption markdown="block">
Overview of the endpoints in the pet shop example.
Arrows indicate dependencies between resources,
for each resource, arrows originating from it point to a resource on which its declaration depends. 
</figcaption>
</figure>

<figure id="0.database-shape" class="listing">
````/code/0.database-shape.shex````
<figcaption markdown="block">
Schema of the database used throughout this section.
</figcaption>
</figure>


[](#5.get-owners) and [](#6.get-owner) define the `<get-owners>` and `<get-owner>` endpoints, respectively.
Both are read interfaces that operate within the state space, as outlined in our vision.
Next, we introduce the write interfaces:
[](#1.post-owner), [](#2.patch-owner), and [](#3.change-owner) define `<post-owner>`, `<patch-owner>`, and `<change-owner>`, respectively -
all of which reside in the event space.

To define a read interface over the event space, one simply declares a resource in terms of an existing event-based dataset.
[](#7.websocket) provides an example of such an event-space read resource.

Finally, we define how the persistent state (i.e., the database) is constructed based on the emitted events.
This composition is shown in [](#4.database-def).

<figure id="5.get-owners" class="listing">
````/code/5.get-owners.ttl````
<figcaption markdown="block">
Definition of a state-space read endpoint at `<http://example.org/owners>`, accessible via HTTP GET and returning a Turtle document.
This endpoint exposes a view over the <database> resource/ graph, listing IRIs corresponding to all registered owners.
</figcaption>
</figure>

<figure id="6.get-owner" class="listing">
````/code/6.get-owner.ttl````
<figcaption markdown="block">
Definition of a parameterized collection of state-space read endpoints using URI templates with variable bindings.
Each endpoint returns a specific owner along with their associated pets and properties.
</figcaption>
</figure>


<figure id="1.post-owner" class="listing">
````/code/1.post-owner.ttl````
<figcaption markdown="block">
Definition of an event-space write endpoint at `https://example.org/owners`,
accepting HTTP POST requests with Turtle payloads.
The input must conform to a specified shape and is mapped to match the structure of the database.
This endpoint allows clients to create a new owner along with a set of initial pets.
</figcaption>
</figure>

<figure id="2.patch-owner" class="listing">
````/code/2.patch-owner.ttl````
<figcaption markdown="block">
Definition of a collection of event-space write endpoints using URI templates with variable bindings.
Each endpoint accepts input conforming to a specific shape and applies a mapping that contextualizes the emitted message for downstream processing.
Different approaches exist but through this mapping we want to show various ways in which you can define your system.
This example demonstrates how clients can patch an owner's name through a structured event.
</figcaption>
</figure>

<figure id="3.change-owner" class="listing">
````/code/3.change-owner.ttl````
<figcaption markdown="block">
Definition of a collection of event-space write endpoints using URI templates with variable bindings.
These endpoints do not require a request body, as all semantics are encoded in the URI.
Upon execution, the system queries the current state, validates the pet's ownership and the existence of the new owner,
and constructs an event describing the necessary additions and deletions in RDF 1.2.
</figcaption>
</figure>

<figure id="7.websocket" class="listing">
````/code/7.websocket.ttl````
<figcaption markdown="block">
Definition of an event-space read endpoint at `https://example.org/transfer-events`,
derived from the events emitted by `<change-owner>` write operations.
As a derived event-space resource, it maintains the transient semantics of the source.
To allow for optimal usage of this event space, this endpoint uses the WebSocket protocol.
</figcaption>
</figure>

<figure id="4.database-def" class="listing">
````/code/4.database-def.ttl````
<figcaption markdown="block">
Definition of the state-space `<database>` resource based on its relationship to three event-space sources.
The transformation from event space to state space is realized through set operations,
represented here using named graphs to clarify which triples are added or removed.
This example vocabulary/ system arbitrarily chose to use named graphs to indicate what set operations are performed over what triples,
but many other choices could be made.
</figcaption>
</figure>

### Example flow
{:#flow-example}

Now that we have introduced our example use case and defined its endpoints using our interim vocabulary,
we can explore how a write operation flows through the system.
While we defer the formalization of algorithms to future work, this section provides an intuitive overview.

Our example includes three write interfaces:
`<post-owner>`, `<patch-owner>`, and `<change-owner>`.
The `<database>` is constructed from all three,
allowing us to trace the provenance of each triple in the resulting dataset back to its originating write interface.
[](#write-interface-tp-prov) shows the output of the various write interfaces in relation to the input, while
[](#9.db-prov) illustrates how specific triples in the database are derived the underlying write operations.

By tracking the provenance of data,
we can describe the structure of the database in relation to the input shapes of the write interfaces.
This enables a reasoning agent, when presented with the database context,
to understand that endpoints like `<get-owners>` and `<get-owner>` can be used to read data.
Moreover, the agent can infer how to perform updates.
For example, if it needs to change an owner's name,
it can determine that it must delete the triple `<some-owner> ex:name "old name"` and insert `<some-owner> ex:name "new name"`.
From the declared interface descriptions,
it can then deduce that this transformation can be achieved by invoking an endpoint defined by `<patch-owner>`.


<figure id="write-interface-tp-prov" class="listing">

<figure id="write-interface-tp-prov-1" class="subfigure">
````/code/8.shape1.shex````
<figcaption markdown="block">
Provenance of triples produced by the `<post-owner>` interface,
illustrating how its input shape relates maps to the resulting triples. (resource defined in [](#1.post-owner))
</figcaption>
</figure>

<figure id="write-interface-tp-prov-2" class="subfigure">
````/code/8.shape2.shex````
<figcaption markdown="block">
Provenance of triples produced by the `<patch-owner>` interface,
illustrating how its input shape relates maps to the resulting triples. (resource defined in [](#2.patch-owner))
</figcaption>
</figure>

<figure id="write-interface-tp-prov-3" class="subfigure">
````/code/8.shape3.shex````
<figcaption markdown="block">
Provenance of triples produced by the `<change-owner>` interface,
illustrating how its input shape relates maps to the resulting triples. (resource defined in [](#3.change-owner))
</figcaption>
</figure>


<figcaption markdown="block">
Triple-level provenance analysis for the write interfaces,
showing the output of individual write interfaces in relation to their input shapes.
</figcaption>
</figure>

<figure id="9.db-prov" class="listing">
````/code/9.db-prov.shex````
<figcaption markdown="block">
Triple-level provenance of the `<database>`,
showing how each segment of its state can be traced back to the input shapes of corresponding write interfaces.
(resource defined in [](#4.database-def))
</figcaption>
</figure>
