## Vision
{:#vision}

Our vision is to connect the reads to the writes by declaring a flow between them declared by algebra. 
There are a few interesting design choices that go into these definitions.
To start of, we notice that change always happens on some time axis, but data reads are not always interested in such a time dimension.
It is not uncommon that read interfaces only expose the data in the state it is at when retrieving the data.
Since our approach tries to be as un-opinionated as possible with regard to the data model used,
we do not force the users of descriptions to model events.
Instead, the description itself operates in two spaces, event space and state space.
And modeling the transition between the two is probably the most challenging part of the system.
As such, we will first explain the system with regard to the state space and only add event space after.

It should also be noted that the data description can model the underlying interface, but does not need to.
As an example, this means that even-though your description uses RDF, your implementation can be a JSON api around a relational dataset -
we mention this explicitly to highlight the versatility of the description.
That being said, the description is sufficient to generate a non-optimized server implementation.
Furthermore, even though our vision is described using SPARQL algebra using the underlying RDF datamodel - other algebras are also possible,
but since we describe web interfaces, an algebra supporting IRIs as first class citizens is likely preferred.
RDF is inetersting for many reasons but the top reason in this work is that IRIs are first class citizens.
As such, it is easy to link between resources, either managed by yourself or by another organization.

### State Space

Modeling the state space is quite trivial and only requires the mapping operation to be an endofunction meaning: $F: A -> A$
In the case of SPARQL, a construct query can be used to represent such a function.
As such, starting from a database $D$, an interface can be defined using some construct query that takes $D$ as a source.
The only thing that remains then is to define the interaction method and http-resource.
The definition of an interaction models ensures that the description is embraces future technological advances and overall interface heterogeneity.
Examples include `HTTP-get`, `SPARQL-1-1`, `GRAPHQL`, etc.
The output of the construct is the dataset that the interaction is wrapped around.
In the case of a SPARQL1.1 interaction method for example, a client interaction with it will need to know how this interaction works,
and this works much the same way as how interface heterogeneity is already tackled for example in Comunica.

In [](#state-def-intro) we sketch an example of what a definition could look like in turtle.
Using a single interface description, possibly infinite interfaces could be described through the use of parameters.
An example way of describing multiple interfaces through a single description is shown in [](#state-def-multiple-interfaces)

### Event space

Operations in the event space follow the same flow as static documents when you stay in event space.
The event space basically 'does not write anything to disk'.
This means that items in the event space are passed around like messages, but they do not get saved.
Any write interface exists in event space by definition.

Resources created within event space, mapped to another resource in event space follow the same definition rules as mappings in state space.
[](#write-init) provides an example definition of a mapping from a write interface to another event space.
The interaction method is similar to the case of reading data, where the client interacts with the interface,
a successful interaction should emit an anonymous graph within the system that is then consumed by the corresponding `idd:mapping`.
[](#event-mapping) shows an example definition of mapping one event-space resource to another.
Note that it is not necessary to bind to an http resource.
There is a strict difference between a dataset uri and the interface uri - where each interface uri has an accompanying dataset uri.
An event space resource can be viewed as a message that flows through the system that can be enriched by different datasets or filtered down in other cases.

### Changing Space

A resource that exists in event space can be converted to exist in state space by applying set operations.
This works based on the fact that the underlying RDF model is a set.
[](#event-to-state-space) shows an example definition of a mapping from event space to state space by using both the 'union' and 'difference' set operations.

You cannot convert a resource from state space to event space, since you do not know when the resource should emit new data in the event system. 
The definition of an event-space resource can off course draw from a state space resource. 

These set operation manipulations have a difficulty when using blanknodes in the underlying RDF model.
We therefore advise against using blanknodes in a state-space resource.
Maybe the mapping could automatically skolomize - but that might not tackle all issues. 

Through the carefully definitions of write interfaces,
consistency within the system can be enforced because dedicated interfaces could pose as dedicated system processes that each guarantee system consistency.


### Consumption of algebraic definitions

We are now able to describe how data flows within an environment, coupling the data reads to the corresponding writes.
Our vision is now that a description such as shown in []() allows an automated agent to scope itself around the various 'read interfaces',
including the `<database>` resource. The agent could then use the derived interfaces to get a picture of the underlying dataset to the best of their ability.
This descriptions would also allow agents to discover modification strategies, meaning they could discover how to change the dataset they focus on.

As an example, take the dataset described through our previous examples.
We thus have two write resources `<post-owner>` and `<patch-owner>`.
They both describe the shape of the resource they expect, and the resource to an internal resource in the event-space.

`<post-owner>` expects
```shex
<> {
    ex:name xsd:string;
    ex:pets {
        foaf:name xsd:string;
        ex:age    xsd:int;
    }*
}
```
The shape after the mapping can be expressed in relation to this input shape:
```
eval()_1 a ex:owner
eval()_1 ex:name xsd:string_1
eval()_1 ex:pets* eval()_2
eval()_2 a ex:pet
eval()_2 ex:name xsd:string_2
eval()_2 ex:age xsd:int_1
```

For `<patch-owners>` the same methodology holds:
```shex
<> {
    ex:name xsd:string;
}
```
maps to:
```
eval()_3 a ex:owner-patch
eval()_3 ex:name xsd:string_3
eval()_3 ex:resource ?patch
```

These mapped resources are then used to construct the `<database>` shape by checking what new data gets in through union operators:
```
eval()_1 a ex:owner
eval()_1 ex:name xsd:string_1 | xsd:string_3
eval()_1 ex:pets* eval_2()
eval()_2 a ex:pet
eval()_2 ex:name xsd:string_2
eval()_2 ex:age xsd:int_1
```

The derived read interfaces `<get-owners>` and `<get-owner>` then allow you to get all owners.
When you want your agent to perform a name change of the owner, you could perform the query using for example SPARQL.
The agent would see that you want to replace triple `<some-owner> ex:name "some name"` with `<some-owner> ex:name "new name"`,
knowing that the original triple is a manifestation of the `<some-owner> ex:name xsd:string_1 | xsd:string_3` triple in the database.
The solver would then infer that the only way to change that triple is by sending `ex:owners/{uuid} ex:name "new name"` to the correct http resource.



To update, one could say: focussing on this resource I want to read it, and I want to write it.
But what the dataset is changes, previously we could only focus on resources exposed on the web, but had no way of seeing the overarching dataset.
This is also important when you **break the symmetry**! (this should be a core motivational part of the paper!)

Can be exposed while being privacy concerning.

