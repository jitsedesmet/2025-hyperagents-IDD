## Algebraic resource descriptions
{:#vision}

Our vision is to bridge the gap between reads and writes by explicitly modeling the intermediate
resources and their algebraic relationships. 
We acknowledge that resources evolve along a temporal axis -
modifications occur over time - but that does not mean resources explicitly model this temporal axis.
We thus model two types of resources:
1. **Stateful resources**: their contained data is durable, meaning their state is written to disc.
These resources always model the latest version of themselves. 
2. **Bus resources**: their contained data is ephemeral. These resources model a bus that can emit resources to the system.

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation,
illustrating the expressive power of the model (e.g. by using tools like [Incremunica](cite:cites incremunica) and [Comunica](cite:cites comunica)).

While our examples are grounded in [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked,
web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful) .

### Stateful resources 

Describing a stateful resource from some other stateful resource(s) is straightforward.
You simply describe your resource using an endofunction $$F:D \rightarrow D$$ (e.g. SPARQL CONSTRUCT).
Once a dependent resource changes, you re-evaluate the function to modify your resource.
 
When you want to expose a resource you can simply declare the interaction method (e.g. HTTP get, SPARQL endpoint) and the representation (e.g. JSON, turtle).
To allow clients to infer the shape-graph of an accessed resource, the shape-graph should not change when converting the data into a desired representation.
Practically, this means that the data described to be accessible cannot be filtered or enriched when converting the RDF model to some representation.

Interaction methods leave room for out of band communication, a client can support a list of interaction methods and representations,
this is akin to how query engines supporting heterogeneous sources allow you to query sources like SPARQL endpoints, but also simple HTTP gets returning various representations like turtle, N-Triples, etc.
Interaction methods allow you to bind variables to your algebraic resource description -
essentially allowing you to create multiple resources and endpoints in one definition.

### Bus resources

In contrast to stateful resources, which are durable, bus resources contain ephemeral data.
You can create a bus resource by describing it in relation to at least one other bus resource and potentially some stateful resources.
The bus resource emits a new event when a dependent bus resource emits a new event.
For each dependent bus resource, the corresponding mapping only has access to that single bus resource and potentially many stateful resources.
Bus resources can be made readable through the definition of an endpoint similar to what we did for stateful resources.

To bootstrap the system, any write endpoint is also a bus resource and calling it creates an event of the described shape.
The description of a write endpoint requires declaring 
1. the interaction method,
2. the representation, and
3. the shape definition of the emitted event.
The first two are similar to what we saw for stateful resources, and similarly can be used to describe multiple write endpoints.
The shape definition describes the shape of data that should be provided to the system after a successful interaction with the endpoint.

Additionally, there is the potential to perform an initial transformation ontop of write interfaces to for example bind identifiers (e.g. through UUIDs),
enrich (e.g. add a timestamp) or restructure the data before it is emitted again in the system.

### Changing resource type

Now that we understand the difference between stateful resources and bus resources, and how to describe them,
we will look at how to declare a stateful resource in relation to some bus resources.
The transition resembles typical approaches of data manipulation queries such as SPARQL updates.   
As such, you can declare a stateful resource by describing how it should be manipulated when a dependent bus resource emits.
This can be done through a SPARQL update query -
or more generally through a list of set operations -
that should be performed on the dataset when the dependent bus resource emits.

Working with blank nodes in this context introduces complications,
because blank nodes are existential and not globally referencable.
You can only reference a blank nodes by querying them from the latest version of the stateful resource since blank node labels do not cary any semantic meaning.

### Consumption of algebraic definitions

With a full description of both read and write interfaces,
we are now equipped to describe how data flows through a system -
how read interfaces derive their data from upstream writes,
and how writes propagate through stateful and bus resources.

Given the description, we can compute the shape-graph and its provenance for each resource.
This information then enables an agent to determine how to query certain views on the resource, and how the resource can be manipulated.
Take for example the shape of our database and its provenance as listed in [](#9.db-prov).
The construction of the full example is provided as part of [](#annex).
The query engine is now able to scope our \<database\>, creating a view of its data as far as it can, given the available endpoints (in this example, it can create a complete view).
The engine can then be tasked to perform some modification, like changing the name, and reason how it can perform such modifications.
In the case of a name modification, the engine would discover that it is able to modify the owners name by calling the \<patch-owner\> endpoint correctly.
What remains is to discover how the shape-graph should be instantiated.

<figure id="9.db-prov" class="listing">
````/code/9.db-prov.shex````
<figcaption markdown="block">
Triple-level provenance of the `<database>`,
showing how each segment of its state can be traced back to the input shapes of corresponding write interfaces.
(resource defined in [](#4.database-def))
</figcaption>
</figure>


These algebraic descriptions enable the agent to:
1. Discover what endpoints provide views over given resources, and how to query them, and 
2. infer how modifications to those resources can be enacted,
by tracing flows back to the corresponding write endpoints,
3. How these endpoints can be used (interaction methods, required shapes), and
4. the use of algebra allows us to optimize the construct-flows into a single big construct query over the write endpoints and the current version of stateful resources. 

In this way, our model enables agents to reason not just about what data resources exists,
but how they came to be, how they can be modified, and what such modifications would entail.
