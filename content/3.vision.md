## Vision
{:#vision}

Our vision is to connect the reads to the writes by declaring a flow between them declared by algebra. 
There are a phew interesting design choices that go into these definitions.
To start of, we notice that modeling change is always done on some time axis while data reads are not always interested in such a time dimension.
It is not uncommon that read interfaces only expose the data in the state it is at when retrieving the data.
Since our approach tries to be as un-opinionated as possible with regard to the data model used,
we do not force the users of descriptions to model events.
Instead, the description itself operates in two spaces, event space and state space.
And modeling the transition between the two is probably the most challenging part of the system.
As such, we will first explain the system with regard to the state space and only add event space after.

It should also be noted that the description a data description can model reality, but does not need to.
This means that even-though your description uses RDF, your implementation can be a JSON api around a relational dataset
- we mention this explicitly to highlight the versatility of the description.
Furthermore, even though our vision is described using SPARQL algebra - other algebras are also possible,
but since we describe web interfaces, an algebra supporting IRIs as first class citizens is likely preferred. 

### State Space

Modeling the state space is quite trivial and only requires the mapping operation to be an endofunction meaning: $F: A -> A$
In the case of SPARQL, a construct query can be used to represent such a function.
As such, starting from a database $D$, an interface can be defined using some construct query that takes $D$ as a source.
The only thing that remains then is to define the interaction method and http-resource.
The definition of an interaction models ensures future process of the description.
Examples include `HTTP-get`, `SPARQL-1-1`, `GRAPHQL`, etc.
The output of the construct is the dataset that the interaction is wrapped around.
In the case of a SPARQL1.1 interaction method for example, a client interaction with it will need to know how this interaction works,
and this works much the same way as how interface heterogeneity is already tackled for example in Comunica.

The definition in the turtle format could have the following form:

<figure id="ruleDef" class="listing">
````/code/state-def-intro.ttl````
<figcaption markdown="block">
Text
</figcaption>
</figure>

Through a single interface description, possibly infinite interfaces could be described through the use of parameters.
A way of modeling this would be through automatic variable binding within the construct query like:

<figure id="ruleDef" class="listing">
````/code/state-def-multiple-interfaces.ttl````
<figcaption markdown="block">
Text
</figcaption>
</figure>

Clear definitions of when a variable gets bounded would be required.

### Event space

Operations in the event space follow the same flow as static documents when you stay in event space.
The event space basically 'does not write anything to disk'.
This means that items in the event space are passed around like messages, but they do not get saved.
Any write interface exists in event space by definition.

An example write interface would be:

<figure id="ruleDef" class="listing">
````/code/write-init.ttl````
<figcaption markdown="block">
Text
</figcaption>
</figure>

The interaction method is similar to the case of reading data,
where the client interacts with the interface,
a successful interaction should emit an anonymous graph that is then consumed by the corresponding `idd:mapping`.

To create another read resource in event space, one simple creates a mapping like before:

<figure id="ruleDef" class="listing">
````/code/event-mapping.ttl````
<figcaption markdown="block">
Text
</figcaption>
</figure>


Note that it is not necessary to bind to an http resource.
There is a strict difference between a dataset uri and the interface uri - where each interface uri has an accompanying dataset uri.
An event space resource can be viewed as a message that flows through the system that can be enriched by different datasets or filtered down in other cases.

### Changing Space

A resource that exists in event space can be converted to exist in state space by applying set operations.
This works based on the fact that the underlying RDF model is a set.
An example of changing space is:

<figure id="ruleDef" class="listing">
````/code/event-to-state-space.ttl````
<figcaption markdown="block">
Text
</figcaption>
</figure>

You cannot convert a resource from state space to event space, since you do not know when the resource should emit. 
The definition of a event-space resource can off course draw from an state space resource. 

These set operation manipulations have a difficulty when using blanknodes.
We therefore advise against using blanknodes in a state-space resource.
Maybe the mapping could automatically skolomize - but that might not tackle all issues. 

The consistency of ACID can be achieved through the intentional definition of update interface.