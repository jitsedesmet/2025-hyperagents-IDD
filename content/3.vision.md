## Algebraic resource descriptions
{:#vision}

Our vision is to bridge the gap between reads and writes by explicitly modeling the intermediate
resources and their algebraic relationships. 
We acknowledge that resources evolve along a temporal axis -
modifications occur over time - but that does not mean resources explicitly model this temporal axis.
We thus model two types of resources:
1. **Persistent resources**: their contained data is persistent, meaning they always model the latest version of themselves and any time related data should be explicitly captured.
2. **Ephemeral resources**: these resources inherently model time, because they only exist at a single moment in time.

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation, illustrating the expressive power of the model.

While our examples are grounded in [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked,
web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful).

### Persistent resources 

Describing a persistent resource from some other persistent resource(s) is straightforward.
You simply describe your resource using an endofunction $$F:D \rightarrow D$$ (e.g. SPARQL CONSTRUCT).
Once a dependent resource changes, you re-evaluate the function to change your resource.
 
When you want to expose a resource you can simply declare the interaction method (e.g. HTTP GET, SPARQL endpoint) and the representation (e.g. JSON, Turtle).
To allow clients to infer the consequences of retrieving an exposed resource, the endpoint should not change the shape-graph when changing representations.
Concretely, our agent can should know exactly what data is provided when retrieving data - no less.

Interaction methods leave room for out of band communication,
allowing clients to support a list of interaction methods and representations.
Interaction methods allow you to bind variables to your algebraic resource description -
essentially allowing you to create multiple resources and endpoints in one definition.

### Ephemeral resources

In contrast to persistent resources, which directly referencable, ephemeral resources are not referencable since they are short-lived, to reference them you require a referencable bus resource.
You can create a bus resource by describing it in relation to at least one other bus resource and potentially some persistent resources.
The bus resource emits a new ephemeral resource when a dependent bus resource emits a new ephemeral resource.
For each dependent bus resource, the corresponding mapping function only has access to that single bus resource and potentially many persistent resources.
The ephemeral resources within a bus can be made readable through the definition of an endpoint similar to what we did for persistent resources.

To bootstrap the system, any write endpoint is also a bus resource because a call to an endpoint is inherently ephemeral, although it's consequences can be persistent.
The description of a write endpoint requires declaring 
1. the interaction method,
2. the representation, and
3. the shape definition of the ephemeral resource after successful interaction.
For example, the `POST /owners` endpoint expects you to interact using a POST on `/owners`, 
using a Turtle representation and after a successful interaction an ephemeral resource containing the data of the new owner and pets will be emitted.

After a successful interaction, an initial transformation can be preformed on the created resource. 
Using this transformation we can for example generate and attach UUIDs to the newly created owner and pets,
or enrich the provided data by adding a timestamp of when this ephemeral resources was created.

### Changing resource type

<!-- Maybe we can merge this paragraph with the last section and remove the next section -->
Now that we understand the difference between persistent resources and ephemeral resources, and how to describe them,
we now explain how ephemeral resources can manipulate persistent resources.
When an ephemeral resource is emitted, it can be used as context to manipulate persistent resources,
either by providing an update query or a list of set operations that should be performed on the persistent resource.

Working with blank nodes in this context introduces complications,
because blank nodes are existential and not globally referencable.
You can only reference a blank nodes by querying them from the latest version of the persistent resource since blank node labels do not cary any semantic meaning.

### Consumption of algebraic definitions

With a full description of both read and write interfaces,
we are now equipped to describe how data flows through a system -
how read interfaces derive their data from upstream writes,
and how writes propagate through persistent and ephemeral resources.

Given the description, we can compute the shape and provenance of each resource.
In our use case it means that for each resource (e.g. `<database>`, all resources of `<get-owner>, ...`)
we know the shape of that resource and how we can manipulate it.
This information enables an agent to determine how to query certain views a specific resource (e.g. `<database>`), and how the resource can be manipulated.
Take for example the shape of our database and its provenance as listed in [](#9.db-prov).
The construction of the full example is provided as part of [](#annex).
An agent can now to scope our `<database>`, creating a view of its data as far as it can, given the available endpoints (in our example, the endpoints cover the complete resource).
The agent can then be tasked to perform some modification, like changing the name, and reason how it can perform such modifications.
In the case of a name modification, the agent would discover that it is able to manipulate the owners name by calling the `<patch-owner>` endpoint correctly.

<figure id="9.db-prov" class="listing">
````/code/9.db-prov.shex````
<figcaption markdown="block">
[ShEx](cite:cites shex) schema of the `<database>` together with the provenance.
This shape and provenance allows an agent to discover what endpoints called to modify our `<database>`.
</figcaption>
</figure>

Our algebraic descriptions enable the agent to:
1. Discover what endpoints provide views over given resources, and how to query them, and 
2. infer how modifications to those resources can be enacted,
by tracing flows back to the corresponding write endpoints,
3. How these endpoints can be used (interaction methods, required shapes), and
4. the use of algebra allows us to optimize the construct-flows into a single big construct query over the write endpoints and the current version of stateful resources. 
<!-- -->
In this way, our model enables agents to reason not just about what data resources exists,
but how they came to be, how they can be modified, and what such modifications would entail.
