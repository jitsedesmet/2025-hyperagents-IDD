## Algebraic resource descriptions
{:#vision}

In this section we will explain our vision by walking through the pet doctor example ([](#interface-viz)).
Within our example definitions we use [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked, web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and
exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful).

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation, illustrating the expressive power of the model.

<span class="comment" data-author="RT">Just an idea, not a big must: Now we start with a write example and then have a read example. Since read is simpler than write, I wonder if we could modify the use case so that read comes first, which could make things easier for the reader.</span>

### Pet registration

We start by focussing on Bob, the proud owner of two cats.
To protect his cats, he requests his agent to register them to the local pet doctor.
Since Bob just moved to a new city, the interface of the local pet doctor's database is not yet known to Bob's agent.
To make Bob agent discover the capabilities of the local pet doctor's database,
the agent first **request a description of the interface** of the local doctor.
Within this description the agent finds how the `<post-owners>` endpoint manipulates the doctors' database.
The agent discovers the **interaction method** (e.g. a POST to `/owners`), the **resource representation** (e.g. [Turtle](cite:cites turtle)),
and the **expected data shape** (e.g. a [ShEx](cite:cites shex) description see [](#owner-shape)).
The interaction method and resource representation allow for out of band communication, since the agent either supports them or does not -
meaning the agent knows their own capabilities.
The shape description allows the agent to infer what information it should provide to the endpoint to facilitate a successful interaction.
The description also provides the agent with knowledge on the **consequences of a successful interaction**
by providing an **algebraic relationship between the endpoint** and, among others, the database resource (e.g. using SPARQL Update, see [](#update-1)). 
By utilizing this interface description, the agent can
1. infer that it should POST Bob's data, and that of the cats, according to the shape to `/owners` in Turtle format.
2. infer that the consequence are safe, and that Bob's cat won't suddenly appear up for sale.

### Requesting pet information

Next in our use case, disaster strikes and one of the cats get sick, to make matters worse our doctor in on holiday.
Bob visits another doctor, and now that doctor requires the medical history of Bob's cat stored on the system of our doctor. 
The other doctor thus tasks their agent to retrieve the files of Bob's sick cat.
Since this agent needs to read data, it would technically be feasible to query all data of our doctors system blindly, and filter on what applies to Bobs cat.
This approach is currently often taken but comes with significant client and server overhead -
our agent is smart and requests the interface description of our doctor their system. 
From this description it notices the existence of our database, containing owners and pets.
Since the database resource is not directly exposed, it looks at other, derived resources, finding
1. `<get-owners>`: list of IRIs of the owner in the system, and
2. `<get-owner>`: parameterized resources containing the info of owner X and their pets.
Each of those resources algebraically describes how they are derived from the database using for example SPARQL CONSTRUCT queries
([](#construct-get-owners) and [](#construct-get-owner)).
When describing parameterized resources, one could use a tentative variable in the query that will be bound at a later point. 
Since the resources are exposed, the description contains just like before the **interaction method** and **representation**.
Using the interaction methods you can link the resource parameters to parts of the interaction method,
as such using the [URI template](cite:cites uri-template) `/owners/{id}` we can bind the '`id`' variable to a variable in the query.
Next, we hypothesize that the agent can use the algebraic descriptions and the input shapes from the manipulation endpoints to
**compute the shape of the data they can expect** when calling the read-endpoints.
Using the expected shapes and parameter definitions, the agent will infer that it can request Bob's data when Bob provides his identifier. 

### Pet transfer

Now to end our story in a positive note, Bob decides to buy a third cat.
He buys the cat from Alice who is already registered at the same doctor,
and asks his agent to register this change of ownership.
Once again, the agent requests the description, this time discovering the `<change-owners>` endpoint.
Like before the endpoint has a required shape description ([](#shape-update-2)), a resource representation, an interaction method, and a query that updates the database ([](#update-2)).
Similar to the parameterized resource before, the update query of `<change-owner>` contains variables that will be bound at a later stage,
the variable in question being '`id`' and '`pet-id`' from the URI template `/owner/{id}/{pet-id}/change-owner`.
It is essential to note that the explicit modeling of the `<database>` plays an essential role in our ability to describe this operation.
The change ownership modification shows the definition of a consistency boundary that not be possible to model with symmetric interface.

### Need for algebraic descriptions

To enable such a use case, there is a need for algebraic descriptions that enable agents to:

1. **Discover endpoints** providing views over given resources, and how to query them,
2. **infer how modifications can be enacted to those resources**, by tracing flows back to the corresponding write endpoints,
3. **how these endpoints can be used** (interaction methods, required shapes), and
4. the use of **algebra allows us to optimize the construct-flows** into a single big construct query over the write endpoints and the current version of persistent resources. <span class="comment" data-author="RT">Not sure about mentioning this last one. Seems like an optimization detail/consequence for point 2. It could also be incorporated into 2 if you really want to keep it.</span>

In this way, such a model enables agents to reason not just about what data resources exists, but how they came to be,
how they can be modified, and what such modifications would entail.

<span class="comment" data-author="RT">Could we split this big listing, and move them closer to the place where they are used? Would improve readability.</span>

<div class="my-big-fig">

<figure id="owner-shape">
````/code/0.database-shape.shex````
<figcaption markdown="block">
ShEx shape of a single owner.  
`<database>` contains many owners.
</figcaption>
</figure>

<figure id="update-1">
````/code/update-database.txt````
<figcaption markdown="block">
`<post-owners>` update query  
on the database.<span class="comment" data-author="RT">Can you replace this caption with what this update query actually means in this context? Something like "Description of how POST operations to X will modify the database". (let's also do this for the other captions)</span>
</figcaption>
</figure>

<figure id="construct-get-owners">
````/code/construct-get-owners.txt````
<figcaption markdown="block">
Construct query for 
`<get-owners>`
</figcaption>
</figure>

<figure id="construct-get-owner">
````/code/construct-get-owner.txt````
<figcaption markdown="block">
Construct query for 
`<get-owner>`
</figcaption>
</figure>


<figure id="shape-update-2">
````/code/shape-construct-get-owner.shex````
<figcaption markdown="block">
`<change-owners>` expected shape.
</figcaption>
</figure>

<figure id="update-2">
````/code/update-database-2.txt````
<figcaption markdown="block">
`<change-owners>` update query  
on the database.
</figcaption>
</figure>

</div>
