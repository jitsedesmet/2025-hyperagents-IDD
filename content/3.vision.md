## Algebraic resource descriptions
{:#vision}

Our vision is to bridge the gap between reads and writes by explicitly modeling the intermediate
resources and their algebraic relationships. 
We acknowledge that resources evolve along a temporal axis -
modifications occur over time - but that does not mean resources explicitly model this temporal axis.
We thus model two types of resources:<span class="comment" data-author="RT">Not a big fan of the names of these two models. I preferred the previous naming. What about "Atemporal" and "Temporal"?</span>
1. **Stateful resources**: their contained data is durable, meaning their state is written to disk<span class="comment" data-author="RT">Could just be to memory as well though. I think you mean "persisted"</span>.
These resources always model the latest version of themselves. 
2. **Bus resources**: their contained data is ephemeral. These resources model a bus that can emit resources to the system.

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation,
illustrating the expressive power of the model (e.g. by using tools like [Incremunica](cite:cites incremunica) and [Comunica](cite:cites comunica) <span class="comment" data-author="RT">I know what you mean by this example, but the reader will not. If you want to give this example, I recommend adding somewhere earlier in the paper (intro or sota) a description/example of how these tools use hypermedia to drive their computations, where it's lacking, and where you go beyond. Not sure you'll have the space for it though, so it could also become part of a future paper instead.</span>).

While our examples are grounded in [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked,
web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful) .

### Stateful resources 

Describing a stateful resource from some other stateful resource(s) is straightforward.
You simply describe your resource using an endofunction $$F:D \rightarrow D$$ (e.g. SPARQL CONSTRUCT).
Once a dependent resource changes, you re-evaluate the function to modify your resource.
 
When you want to expose a resource you can simply declare the interaction method (e.g. HTTP GET, SPARQL endpoint) and the representation (e.g. JSON, Turtle).
To allow clients to infer the shape-graph of an accessed resource<span class="comment" data-author="RT">What is this shape-graph you're talking about? And why would clients want to infer it? Connecting it to your use case would make this clearer.</span>, the shape-graph should not change when converting the data into a desired representation.
Practically, this means that the data described to be accessible cannot be filtered or enriched when converting the RDF model to some representation.<span class="comment" data-author="RT">I didn't really get this paragraph tbh :-(</span>

Interaction methods leave room for out of band communication, a client can support a list of interaction methods and representations,
this is akin to how query engines supporting heterogeneous sources allow you to query sources like SPARQL endpoints<span class="comment" data-author="RT">You come back to this query engine example again. Wouldn't it be better to use the query engine use case as part of your running example then? Either that, or connect this here directly to your pet shop example.</span>, but also simple HTTP gets returning various representations like turtle, N-Triples, etc.
Interaction methods allow you to bind variables to your algebraic resource description -
essentially allowing you to create multiple resources and endpoints in one definition.

### Bus resources

In contrast to stateful resources, which are durable, bus resources contain ephemeral data.
You can create a bus resource by describing it in relation to at least one other bus resource and potentially some stateful resources.
The bus resource emits a new event when a dependent bus resource emits a new event.
For each dependent bus resource, the corresponding mapping only has access to that single bus resource and potentially many stateful resources.
Bus resources can be made readable through the definition of an endpoint similar to what we did for stateful resources.

<span class="comment" data-author="RT">This paragraph is very abstract. I recommend explaining it in terms of a/the use case.</span>
To bootstrap the system, any write endpoint is also a bus resource and calling it creates an event of the described shape.
The description of a write endpoint requires declaring 
1. the interaction method,
2. the representation, and
3. the shape definition of the emitted event.
The first two are similar to what we saw for stateful resources, and similarly can be used to describe multiple write endpoints.
The shape definition describes the shape of data that should be provided to the system after a successful interaction with the endpoint.

<span class="comment" data-author="RT">You say there's a potential to do this. But where is the need? This should become clear again from your use case connection.</span>
Additionally, there is the potential to perform an initial transformation on top of write interfaces to for example bind identifiers (e.g. through UUIDs),
enrich (e.g. add a timestamp) or restructure the data before it is emitted again in the system.

### Changing resource type

<span class="comment" data-author="RT">I feel like this subsection raises more questions than it solves. I don't think there's a strong need to include this one in this paper. (unless of course, it is needed to cover your use case)</span>

Now that we understand the difference between stateful resources and bus resources, and how to describe them,
we will look at how to declare a stateful resource in relation to some bus resources.
The transition resembles typical approaches of data manipulation queries such as SPARQL updates.   
As such, you can declare a stateful resource by describing how it should be manipulated when a dependent bus resource emits.
This can be done through a SPARQL update query -
or more generally through a list of set operations -
that should be performed on the dataset when the dependent bus resource emits.

Working with blank nodes in this context introduces complications,
because blank nodes are existential and not globally referencable.
You can only reference a blank nodes by querying them from the latest version of the stateful resource since blank node labels do not cary any semantic meaning.

### Consumption of algebraic definitions

With a full description of both read and write interfaces,
we are now equipped to describe how data flows through a system -
how read interfaces derive their data from upstream writes,
and how writes propagate through stateful and bus resources.

Given the description, we can compute the shape-graph <span class="comment" data-author="RT">What is the definition of a shape-graph?</span> and its provenance <span class="comment" data-author="RT">What do you mean with provenance exactly? (as different people will expect different things)</span> for each resource.
This information then enables an agent to determine how to query certain views on the resource, and how the resource can be manipulated.
Take for example the shape of our database and its provenance as listed in [](#9.db-prov).
The construction of the full example is provided as part of [](#annex).
The query engine is now able to scope our \<database\>, creating a view of its data as far as it can, given the available endpoints (in this example, it can create a complete view).
The engine can then be tasked to perform some modification, like changing the name, and reason how it can perform such modifications.
In the case of a name modification, the engine would discover that it is able to modify the owners name by calling the \<patch-owner\> endpoint correctly.
What remains is to discover how the shape-graph should be instantiated.

<figure id="9.db-prov" class="listing">
````/code/9.db-prov.shex````
<figcaption markdown="block">
[ShEx](cite:cites shex) schema of the `<database>` together with the provenance.
</figcaption>
</figure>

<span class="comment" data-author="RT">I don't see how this listing achieves what you describe below.</span>

These algebraic descriptions enable the agent to:
1. Discover what endpoints provide views over given resources, and how to query them, and 
2. infer how modifications to those resources can be enacted,
by tracing flows back to the corresponding write endpoints,
3. How these endpoints can be used (interaction methods, required shapes), and
4. the use of algebra allows us to optimize the construct-flows into a single big construct query over the write endpoints and the current version of stateful resources. 

In this way, our model enables agents to reason not just about what data resources exists,
but how they came to be, how they can be modified, and what such modifications would entail.
