## Algebraic resource descriptions
{:#vision}

In this section we will explain our vision by walking through the pet doctor example ([](#interface-viz)).
Within our example definitions we use [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked, web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and
exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful).

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction, much like a blueprint,
the algebraic description is sufficient to generate a server implementation,
illustrating the expressive power of the model.


**Pet registration** -
<!-- -->
We start by focussing on Bob, the proud owner of two cats.
To protect his cats, he requests his agent to register them to the local pet doctor.
Since Bob just moved to a new city, the interface of the local pet doctor's database is not yet known to Bob's agent.
To make Bob's agent discover the capabilities of the local pet doctor's database,
the agent first **request a description of the interface** of the local doctor.
Within this description the agent finds how the `<post-owners>` endpoint manipulates the doctors' database.
The agent discovers the **interaction method** (e.g. a POST to `/owners`), the **resource representation** (e.g. [Turtle](cite:cites turtle)),
and the **expected data shape** (e.g. a [SPARQL ASK](cite:cites spec:sparqllang) query see [](#owner-shape)).
The interaction method and resource representation allow for out of band communication, since the agent either supports them or does not -
meaning the agent knows their own capabilities.
The shape description allows the agent to infer what information it should provide to the endpoint to facilitate a successful interaction.
The description also provides the agent with knowledge on the **consequences of a successful interaction**
by providing an **algebraic relationship between the endpoint** and, among others, the database resource (e.g. using SPARQL Update, see [](#update-1)). 
By utilizing this interface description, the agent can
1. infer that it should POST Bob's data and that of the cats, according to the shape to `/owners` in Turtle format.
2. verify the consequences are what is expected and that Bob's cat won't suddenly appear up for sale.

**Requesting pet information** -
<!-- -->
Next in our use case, disaster strikes and one of the cats get sick, to make matters worse our doctor is on holiday.
Bob visits another doctor, and now that doctor requires the medical history of Bob's cat stored on the system of our doctor. 
The other doctor thus tasks their agent to retrieve the files of Bob's sick cat.
Since this agent needs to read data, it would technically be feasible to query all data of our doctor's system blindly, and filter on what applies to Bobs cat.
This approach is currently often taken but comes with significant client and server overhead -
our agent is smart and requests the interface description of our doctor's system. 
From this description it notices the existence of the database, containing owners and pets.
Since the database resource is not directly exposed, it looks at other, derived resources, finding
1. `<get-owners>`: list of IRIs of the owner in the system, and
2. `<get-owner>`: parameterized resources containing the info of owner X and their pets.
Each of those resources algebraically describes how they are derived from the database (e.g. using [SPARQL CONSTRUCT](cite:cites spec:sparqllang) queries, see
[](#construct-get-owners) and [](#construct-get-owner)).
When describing parameterized resources, one could use a tentative variable in the query that will be bound at a later point. 
Since the resources are exposed, the description contains just like before the **interaction method** and **representation**.
Using the interaction methods you can link the resource parameters to parts of the interaction method,
as such using the [URI template](cite:cites uri-template) `/owners/{id}` we can bind the '`id`' variable to a variable in the query.
Next, we hypothesize that the agent can use the algebraic descriptions and the input shapes from the manipulation endpoints to
**compute the shape of the data they can expect** when calling the read-endpoints.
Using the expected shapes and parameter definitions, the agent will infer that it can request both Bob's data and that of his cats when Bob provides his identifier. 

**Pet transfer** -
<!-- -->
Now to end our story in a positive note, Bob decides to buy a third cat.
He buys the cat from Alice who is already registered at the same doctor,
and asks his agent to register this change of ownership.
Once again, the agent requests the description, this time discovering the `<change-owners>` endpoint.
Like before, the endpoint has a required shape description ([](#shape-update-2)), a resource representation, an interaction method, and a query that updates the database ([](#update-2)).
Similar to the parameterized resource before, the update query of `<change-owner>` contains variables that will be bound at a later stage,
the variable in question being '`id`' and '`pet-id`' from the URI template `/owner/{id}/{pet-id}/change-owner`.
It is essential to note that the explicit modeling of the `<database>` plays an essential role in our ability to describe this operation.
The change ownership modification shows the definition of a **consistency boundary** that would not be possible to model using symmetric interfaces.

**Need for algebraic descriptions** -
<!-- -->
To conclude we hypothesize that our algebraic descriptions enable agents to:
<!-- -->
1. **Discover endpoints** providing views over given resources, and how to query them,
2. **infer how modifications can be enacted to those resources**, by tracing flows back to the corresponding write endpoints, and
3. **how these endpoints can be used** (interaction methods, required shapes).
<!-- -->
In this way, our model enables agents to reason not just about what data resources exist, but how they came to be,
how they can be modified, and what such modifications would entail.

<div class="my-big-fig">

<figure id="owner-shape">
````/code/0.database-shape.shex````
<figcaption markdown="block">
ShEx shape of a single owner.  
`<database>` contains many owners.
</figcaption>
</figure>

<figure id="update-1">
````/code/update-database.txt````
<figcaption markdown="block">
Declarative description to the agent of how `<post-owners>` manipulates the `<database>`.
</figcaption>
</figure>

<figure id="construct-get-owners">
````/code/construct-get-owners.txt````
<figcaption markdown="block">
Declarative description to the agent of how `<get-owners>` is derived from the `<database>`.
</figcaption>
</figure>

<figure id="construct-get-owner">
````/code/construct-get-owner.txt````
<figcaption markdown="block">
Declarative description to the agent of how `<get-owner>` is derived from the `<database>` using parameter '`id`'.
</figcaption>
</figure>


<figure id="shape-update-2">
````/code/shape-construct-get-owner.shex````
<figcaption markdown="block">
Declarative description of what data shape the agent should provide when communication with `<change-owners>`.
</figcaption>
</figure>

<figure id="update-2">
````/code/update-database-2.txt````
<figcaption markdown="block">
Declarative description to the agent of how `<change-owners>` manipulates the `<database>`.
</figcaption>
</figure>

</div>
