## Algebraic resource descriptions
{:#vision}

Our vision is to bridge the gap between reads and writes by explicitly modeling the intermediate
resources and their algebraic relationships. 
We acknowledge that resources evolve along a temporal axis -
modifications occur over time - but that does not mean resources explicitly model this temporal axis.
We thus model two types of resources:
1. **Stateful resources**: their contained data is durable, meaning their state is written to disc.
These resources always model the latest version of themselves. 
2. **Bus resources**: their contained data is ephemeral. These resources model a bus that can emit resources to the system.

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation,
illustrating the expressive power of the model (e.g. by using tools like Incremunica<span class="comment" data-author="JDS">add ref</span> and [Comunica](cite:cites comunica)).

While our examples are grounded in [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked,
web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra)) .

### Stateful resources 

Describing a stateful resource from some other stateful resource(s) is straightforward.
You simply describe your resource using an endofunction $$F:D \rightarrow D$$ (e.g. SPARQL CONSTRUCT).
Once a dependent resource changes, you re-evaluate the function to modify your resource.
 
When you want to expose a resource you can simply declare the interaction method (e.g. HTTP get, SPARQL endpoint) and the representation (e.g. JSON, turtle).
To allow clients to infer the shape-graph of an accessed resource, the shape-graph should not change when converting the data into a desired representation.
Practically, this means that the data described to be accessible cannot be filtered or enriched when converting the RDF model to some representation.

Interaction methods leave room for out of band communication, a client can support a list of interaction methods and representations,
this is akin to how Comunica allows you to query heterogeneous sources like SPARQL endpoints, but also simple HTTP gets returning various representations like
turtle, N-Triples, etc.
Interaction methods allow you to bind variables to your algebraic resource description -
essentially allowing you to create multiple resources and endpoints in one definition.

### Bus resources

In contrast to stateful resources, which are durable, bus resources contain ephemeral data.
You can create a bus resource by describing it in relation to at least one other bus resource and potentially some stateful resources.
The bus resource emits a new event when a dependent bus resource emits a new event.
For each dependent bus resource, the corresponding mapping only has access to that single bus resource and potentially many stateful resources.
Bus resources can be made readable through the definition of an endpoint similar to what we did for stateful resources.

To bootstrap the system, any write endpoint is also a bus resource and calling it creates an event of the described shape.
The description of a write endpoint requires declaring 
1. the interaction method,
2. the representation, and
3. the shape definition of the emitted event.
The first 2 are similar to what we saw for stateful resources, and similarly can be used to describe multiple write endpoints.

The transformations ontop of write interfaces can be used to for example bind identifiers (e.g. through UUIDs),
enrich (e.g. add a timestamp) or restructure the data.

### Changing resource type

Now that we understand the difference between stateful resources and bus resources, and how to describe them,
we will now look at how to declare a stateful resource in relation to some bus resources.
The transition resembles typical approaches of data manipulation queries such as SPARQL updates.   
As such, you can declare a stateful resource by describing how it should be manipulated when a dependent bus resource emits.
This can be done through a SPARQL update query -
or more generally through a list of set operations -
that should be performed on the dataset when the dependent bus resource emits.

Working with blank nodes in this context introduces complications,
because blank nodes are existential and not globally referencable.
You can only reference a blank node by querying it in the latest version of the stateful resource since blank node labels do not cary any semantic meaning.

### Consumption of algebraic definitions

With a full description of both read and write interfaces,
we are now equipped to describe how data flows through a system -
how read interfaces derive their data from upstream writes,
and how writes propagate through event and state space into persistent views.

Given such a description (e.g. as shown in [](#annex)) <span class="comment" data-author="RT">You can't refer to an appendix like this. If it's necessary to understand the work, it must be included. Appendix is only for optional supplementary work.</span>,
an automated agent can scope itself to the relevant datasets (e.g. `<database>` <span class="comment" data-author="RT">Not sure what is meant by this example</span>),
and infer how to interact with the system to both read and modify data.

These algebraic descriptions enable the agent to:
1. Discover what interfaces provide views over the dataset, and how to query them, and 
2. infer how modifications to those views can be enacted,
by tracing flows back to the corresponding write interfaces (see [](#flow-example)).
3. Additionally, the use of algebra allows us to optimize the construct-flows into a single big construct query over
the write interfaces and the current version of persisted stores. 

This algebraic interface description provides more than just interaction details.
It conveys:
1. What endpoints can be used to read or modify a dataset. 
2. How these endpoints can be used (interaction methods, required shapes). 
3. Why certain interactions affect the state (tracing data provenance). 
4. What consequences a modification will have (based on how state is computed from events).

In this way, our model enables agents to reason not just about what data exists,
but how it came to be, how it can be changed, and what such changes would entail.
