## Algebraic resource descriptions
{:#vision}

In this section we will explain our vision by walking through the pet store example ([](#interface-viz)).
Within our example definitions we use [SPARQL algebra](cite:cites spec:sparqllang) over [RDF](cite:cites spec:rdf) -
due to RDF's strengths in representing linked,
web-native data using IRIs - the broader approach is algebra-agnostic.
Any algebra that can express data transformations in a way that preserves semantic meaning and exposes IRIs as first-class citizens could be used (e.g. [RML algebra](cite:cites rml-algebra) seems particularly useful).

Our vision is to bridge the gap between reads and writes by explicitly modeling the intermediate
resources and their algebraic relationships. 
We acknowledge that resources evolve along a temporal axis -
modifications occur over time - but that does not mean resources explicitly model this temporal axis.
We thus model two types of resources:
1. **Persistent resources**: their contained data is persistent, meaning they always model the latest version of themselves and any time related data should be explicitly captured.
2. **Ephemeral resources**: only exist at a single moment in time, and are thereby inherently and implicitly tied to a specific moment in time.

We also emphasize that the description is there to help clients and should only be correct in regard to the behaviour of the described system,
it is thus decoupled from the underlying implementation.
For example, an RDF-based description may describe a JSON API backed by a relational database.
Despite this abstraction,
the algebraic description is sufficient to generate a server implementation, illustrating the expressive power of the model.

### System modeling

**The database resource** is essential in our use case, and can be referenced using the `<database>` IRI.
It's an intermediate resource capturing "_all known owners and their pets registered in our system_".
Since it's an intermediate resource, it is not exposed as a whole, instead other resources such as
`<get-owners>` (_list of owners registered in our system_) and the parameterised
`<get-owner>` (_all data of the owner X, including their pets, registered in our system_)
are derived from the database and are exposed through endpoints. 
Likewise, to manipulate the database resource the `<post-owner>`, `<patch-owner>` and `<change-owner>` endpoints can be used.
Later we will interpret these manipulation endpoints not just as endpoints but as ways to create ephemeral resources.
Using this terminology: our goal is to allow an agent to autonomously interact with the database resource -
meaning an agent can manipulate the database resource by understanding the declarative relation between the database and the manipulation endpoints,
and the agent can request the database by requesting the derived resources (which together cover the whole database resource).

**The `<get-owners>`** resource is derived from the database using a simple SPARQL CONSTRUCT query.
To tie an endpoint to this resource, allowing it to be exposed, we also define the interaction method (e.g. SPARQL endpoint, HTTP GET),
and the representation (e.g. JSON, Turtle).
<!-- -->
These interaction methods and representations leave room for out of band communication,
agents know whether they can perform a certain interaction method and whether they can parse certain representations.


<div style="display: grid; grid-template-columns: 1fr 1fr; min-width: 0;">

<figure id="database-shape" style="min-width: 0;">
````/code/0.database-shape.shex````
<figcaption markdown="block">
[ShEx](cite:cits shex) shape of the  
`<database>` resource.
</figcaption>
</figure>

<figure id="my-figure" style="min-width: 0;">
````/code/temp.txt````
<figcaption markdown="block">
Definition of the `<get-owner>`  
resource. Parameterized over the   
owner-uuid variable.
</figcaption>
</figure>

</div>


**`<get-owner>`** is a parameterized resource, meaning you need to know certain variables in order to pinpoint what resource you are talking about.
Once again the resource is derived from the database using a SPARQL construct query, but this time the query contains some variables that still need to be bound.
Parameterized resources are interesting when you want to declare multiple endpoints, since the interaction method can allow you to bind the variables.
For example a variable in the SPARQL query could be bound to a specific [URI query parameter](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Query).

Up until now we have only talked about persistent resources, meaning the resources always exist and model their latest state.
Next we talk about **ephemeral resources**, these only exist at one specific instance in time, for example '_a write to the system_', or '_a message through a system_'.
Since an ephemeral resource itself can not be referenced, we use **bus resources** to capture and reference '_ephemeral resources emitted to a bus_'.
We model write endpoints as a bus resource and a write to an endpoint as an ephemeral resource on the bus.
More concretely:
1. **`<post-owners>`** is a bus capturing successful interaction using POST on `/owners`,
2. **`<patch-owners>`** is a parameterized bus resource capturing successful interactions using PATCH on `/owner/{id}`, and
3. **`<change-owners>`** is a parameterized bus resource capturing successful interactions using POST on `/owner/{id}/{pet-id}/change-owner`.
The definition of these write endpoints includes a definition of the expected shape (e.g. ShEx shape) of the created ephemeral resources -
by defining these shapes, we can deduce the shape of the derived resources, and agents know what data is expected.  

Created ephemeral resources can be derived into new ephemeral resources similar to what we saw for persistent resources (using SPARQL CONSTRUCT).
They can also be used to enact modifications on persistent resources by defining a SPARQL update query (or list of set-operations)
that has access to both the ephemeral resource and the persistent resources.
The creation of an ephemeral resource essentially acts as a trigger for modifications.
Naturally, just like how stateful resources can be exposed by declaring interaction method and representation,
the same can be done for bus resources, allowing you to expose a bus using for example WebSockets or MQTT. 

### Agent manipulations

With a full description of both read and write interfaces,
we are now equipped to describe how data flows through a system -
how read interfaces derive their data from upstream writes,
and how writes propagate through persistent and ephemeral resources.
The remainder of this section includes our main hypotheses.

Given the relation between our write endpoints and the database,
an agent can compute the shape of the database resource itself.
Additionally, the agent can compute the data provenance of those shapes,
meaning it knows what endpoints manipulate the resource in what way.
We hypothesize that our algebraic descriptions enable the agent to:
1. Discover what endpoints provide views over given resources, and how to query them, and
2. infer how modifications to those resources can be enacted, by tracing flows back to the corresponding write endpoints,
3. How these endpoints can be used (interaction methods, required shapes), and
4. the use of algebra allows us to optimize the construct-flows into a single big construct query over the write endpoints and the current version of persistent resources.
In this way, our model enables agents to reason not just about what data resources exists, but how they came to be,
how they can be modified, and what such modifications would entail.
